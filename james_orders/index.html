<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>제임스트렌스 주문서 처리</title>
    <meta name="description" content="주문 엑셀 파일을 업로드하여 주소, 전화번호, 회사명 데이터를 자동으로 정리하고 다운로드하는 웹 애플리케이션입니다.">
    <meta name="theme-color" content="#f8fafc" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2316a34a'%3E%3Cpath d='M4 2h14a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6l-4-4V4a2 2 0 0 1 2-2zm8 11.5v-3h-3v-2h3v-3h2v3h3v2h-3v3h-2z'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>
<body class="bg-slate-100 dark:bg-slate-800">
    <div id="root"></div>
    <script type="module">
        import React, { useState, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- Inlined Services (from services/fileProcessor.ts) ---
        const findKeyByKeyword = (headers, keyword) => {
            return headers.find(h => h.trim().replace(/\s+/g, '').includes(keyword));
        };

        const processOrderData = (data, headers) => {
            const originalAddressKey = findKeyByKeyword(headers, '建物名');
            const prefectureKey = findKeyByKeyword(headers, '都道府県');
            const companyKey = findKeyByKeyword(headers, '会社名');
            const recipientKey = findKeyByKeyword(headers, '届け先名');
            const phoneKey = findKeyByKeyword(headers, '注文者電話番号');
            const recipientPhoneKey = findKeyByKeyword(headers, '수령자휴대폰번호');

            const finalData = data.map(originalRecord => {
                const record = { ...originalRecord };

                if (originalAddressKey && prefectureKey) {
                    const fullAddress = record[originalAddressKey];
                    if (typeof fullAddress === 'string' && fullAddress.trim() !== '') {
                        const prefectureRegex = /^(東京都|北海道|大阪府|京都府|.{2,3}県)(.*)$/;
                        const match = fullAddress.match(prefectureRegex);
                        if (match && match[1]) {
                            record[prefectureKey] = match[1].trim();
                            record[originalAddressKey] = (match[2] || '').trim();
                        } else {
                            record[prefectureKey] = '';
                        }
                    } else {
                        record[prefectureKey] = '';
                    }
                }

                if (phoneKey) {
                    let finalPhone = record[phoneKey];
                    const recipientPhone = recipientPhoneKey ? record[recipientPhoneKey] : undefined;
                    const isPhoneEmpty = (phone) => {
                        if (phone === null || phone === undefined || phone === 0) return true;
                        if (typeof phone === 'string') {
                            const trimmed = phone.trim();
                            if (trimmed === '' || trimmed === '-') return true;
                            const cleanedForCheck = trimmed.replace(/^\+81-?/, '').trim();
                            return cleanedForCheck === '' || cleanedForCheck === '-' || cleanedForCheck === '--';
                        }
                        return false;
                    };
                    if (isPhoneEmpty(finalPhone)) {
                        if (recipientPhone && !isPhoneEmpty(recipientPhone)) {
                            finalPhone = recipientPhone;
                        }
                    }
                    if (finalPhone) {
                        let cleaned = String(finalPhone).replace(/^\+81-?/, '');
                        record[phoneKey] = (cleaned.trim() === '--' || cleaned.trim() === '-') ? '' : cleaned.trim();
                    } else {
                        record[phoneKey] = '';
                    }
                }

                if (companyKey && recipientKey) {
                    const companyName = record[companyKey];
                    if (typeof companyName === 'string' && companyName.trim() !== '') {
                        record[recipientKey] = companyName;
                        record[companyKey] = '';
                    }
                }
                
                if (recipientPhoneKey) {
                    delete record[recipientPhoneKey];
                }
                return record;
            });
            
            const finalHeaders = headers.filter(h => h !== recipientPhoneKey);
            return { processedData: finalData, processedHeaders: finalHeaders };
        };

        const readAndProcessFile = (file) => {
            return new Promise((resolve, reject) => {
                const handleFullFileRead = (e, isHtml) => {
                    try {
                        const data = e.target?.result;
                        let workbook;
                        if (isHtml) {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(data, 'text/html');
                            const table = doc.querySelector('table');
                            if (!table) throw new Error('HTML 파일에서 테이블을 찾을 수 없습니다.');
                            const worksheet = XLSX.utils.table_to_sheet(table, { raw: true });
                            workbook = XLSX.utils.book_new();
                            XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
                        } else {
                            workbook = XLSX.read(data, { type: 'array' });
                        }
                        const sheetName = workbook.SheetNames[0];
                        if (!sheetName) throw new Error('파일에 시트가 없습니다.');
                        const worksheet = workbook.Sheets[sheetName];
                        const headers = (XLSX.utils.sheet_to_json(worksheet, { header: 1 })[0]) || [];
                        if (headers.length === 0) throw new Error('파일에서 헤더를 찾을 수 없습니다. 파일이 비어있거나 형식이 잘못되었습니다.');
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        resolve(processOrderData(jsonData, headers));
                    } catch (err) {
                        console.error(err);
                        if (err instanceof Error) {
                            reject('파일 처리 중 오류가 발생했습니다: ' + err.message);
                        } else {
                            reject('파일 처리 중 알 수 없는 오류가 발생했습니다.');
                        }
                    }
                };

                const typeDetectionReader = new FileReader();
                typeDetectionReader.onload = (e) => {
                    if (!e.target?.result) {
                        return reject('파일 형식을 감지하는 데 실패했습니다.');
                    }
                    const arr = new Uint8Array(e.target.result);
                    let firstChar = '';
                    for (let i = 0; i < arr.length; i++) {
                        const char = String.fromCharCode(arr[i]);
                        if (char.trim() !== '') {
                            firstChar = char;
                            break;
                        }
                    }
                    const isHtml = firstChar === '<';
                    const mainReader = new FileReader();
                    mainReader.onerror = () => reject('파일을 읽는 데 실패했습니다.');
                    mainReader.onload = (event) => handleFullFileRead(event, isHtml);
                    if (isHtml) {
                        mainReader.readAsText(file, 'UTF-8');
                    } else {
                        mainReader.readAsArrayBuffer(file);
                    }
                };
                typeDetectionReader.onerror = () => reject('파일 형식을 감지하는 데 실패했습니다.');
                typeDetectionReader.readAsArrayBuffer(file.slice(0, 10));
            });
        };


        // --- Inlined Components (from components/index.tsx) ---
        const ArrowPathIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-4.991-2.696h-4.992v.001M21.015 4.356v4.992m0 0h-4.992m4.992 0l-3.181-3.183a8.25 8.25 0 00-11.664 0L2.985 9.348" }));
        const CheckCircleIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }));
        const DownloadIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" }));
        const ExcelIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", ...props }, React.createElement("path", { d: "M4 2h14a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6l-4-4V4a2 2 0 0 1 2-2zm8 11.5v-3h-3v-2h3v-3h2v3h3v2h-3v3h-2zm-3.5-6.5L10 8.5 8.5 7l-1.5 1.5L8.5 10l1.5-1.5L11.5 10l1.5-1.5-1.5-1.5L10 8.5 8.5 7zM6 18h12v2H6v-2z" }));
        const InformationCircleIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", ...props }, React.createElement("path", { fillRule: "evenodd", d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm8.706-1.442c1.146-.573 2.437.463 2.126 1.706l-.709 2.836.042-.02a.75.75 0 0 1 .67 1.34l-.04.022c-1.147.573-2.438-.463-2.127-1.706l.71-2.836-.042.02a.75.75 0 1 1-.671-1.34l.041-.022zM12 9a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z", clipRule: "evenodd" }));
        const PaperAirplaneIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" }));
        const SpinnerIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", ...props }, React.createElement("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), React.createElement("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
        const TrashIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.067-2.09 1.02-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" }));
        const UploadIcon = (props) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" }));

        const Button = ({ isLoading = false, children, className, ...props }) => {
            const baseClasses = "inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-slate-900 transition-all duration-150";
            const colorClasses = "bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600";
            const disabledClasses = "disabled:bg-slate-400 disabled:dark:bg-slate-600 disabled:cursor-not-allowed";
            return React.createElement("button", { type: "button", className: `${baseClasses} ${colorClasses} ${disabledClasses} ${className}`, disabled: isLoading || props.disabled, ...props },
                isLoading && React.createElement(SpinnerIcon, { className: "animate-spin -ml-1 mr-3 h-5 w-5 text-white" }),
                children
            );
        };
        
        const DataTablePreview = ({ data, headers }) => {
            if (!data || data.length === 0) {
                return React.createElement("p", { className: "pl-14 text-slate-500" }, "표시할 데이터가 없습니다.");
            }
            const displayHeaders = headers && headers.length > 0 ? headers : Object.keys(data[0] || {});
            const previewData = data.slice(0, 10);
            return React.createElement("div", { className: "pl-14" },
                React.createElement("div", { className: "overflow-x-auto rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50" },
                    React.createElement("table", { className: "min-w-full divide-y divide-slate-200 dark:divide-slate-700" },
                        React.createElement("thead", { className: "bg-slate-100 dark:bg-slate-800" },
                            React.createElement("tr", null,
                                displayHeaders.map((header) => React.createElement("th", { key: header, scope: "col", className: "px-6 py-3 text-left text-sm font-medium text-slate-500 dark:text-slate-300 uppercase tracking-wider whitespace-nowrap" }, header))
                            )
                        ),
                        React.createElement("tbody", { className: "bg-white dark:bg-slate-900 divide-y divide-slate-200 dark:divide-slate-700" },
                            previewData.map((row, rowIndex) =>
                                React.createElement("tr", { key: rowIndex, className: "hover:bg-slate-50 dark:hover:bg-slate-800/70" },
                                    displayHeaders.map((header, colIndex) =>
                                        React.createElement("td", { key: `${rowIndex}-${colIndex}`, className: "px-6 py-4 whitespace-nowrap text-base text-slate-700 dark:text-slate-300" }, String(row[header] ?? ''))
                                    )
                                )
                            )
                        )
                    )
                ),
                data.length > 10 && React.createElement("p", { className: "text-right text-base text-slate-500 mt-2 pr-2" }, `... and ${data.length - 10} more rows.`)
            );
        };

        const FileUpload = ({ onFileSelect, file }) => {
            const [isDragging, setIsDragging] = useState(false);
            const handleDragEnter = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); };
            const handleDrop = (e) => {
                e.preventDefault(); e.stopPropagation(); setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) onFileSelect(e.dataTransfer.files[0]);
            };
            const handleFileChange = (e) => { if (e.target.files && e.target.files.length > 0) onFileSelect(e.target.files[0]); };
            const handleRemoveFile = () => { onFileSelect(null); };

            const baseClasses = "relative block w-full border-2 border-dashed rounded-lg p-8 text-center transition-colors duration-200 ease-in-out cursor-pointer";
            const draggingClasses = "border-blue-500 bg-blue-50 dark:bg-blue-900/30";
            const defaultClasses = "border-slate-300 dark:border-slate-600 hover:border-blue-400 dark:hover:border-blue-500";
            
            if (file) {
                return React.createElement("div", { className: "pl-14" },
                    React.createElement("div", { className: "flex items-center justify-between p-4 bg-slate-100 dark:bg-slate-800 rounded-lg" },
                        React.createElement("div", { className: "flex items-center space-x-3" },
                            React.createElement(ExcelIcon, { className: "w-8 h-8 text-green-600 dark:text-green-500" }),
                            React.createElement("span", { className: "font-medium text-slate-700 dark:text-slate-300" }, file.name)
                        ),
                        React.createElement("button", { onClick: handleRemoveFile, className: "p-2 rounded-full text-slate-500 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors" },
                            React.createElement(TrashIcon, { className: "w-5 h-5" })
                        )
                    )
                );
            }
            return React.createElement("div", { className: `${baseClasses} ${isDragging ? draggingClasses : defaultClasses}`, onDragEnter: handleDragEnter, onDragLeave: handleDragLeave, onDragOver: handleDragOver, onDrop: handleDrop },
                React.createElement("input", { type: "file", id: "file-upload", className: "absolute inset-0 w-full h-full opacity-0 cursor-pointer", onChange: handleFileChange, accept: ".xlsx, .xls, .html, .htm" }),
                React.createElement("div", { className: "flex flex-col items-center justify-center space-y-3" },
                    React.createElement(UploadIcon, { className: "w-12 h-12 text-slate-400 dark:text-slate-500" }),
                    React.createElement("p", { className: "text-slate-600 dark:text-slate-400" },
                        React.createElement("span", { className: "font-semibold text-blue-600 dark:text-blue-400" }, "파일 선택"), " 또는 드래그 앤 드롭"
                    ),
                    React.createElement("p", { className: "text-xs text-slate-500 dark:text-slate-500" }, "XLSX, XLS, 또는 HTML 파일")
                )
            );
        };


        // --- Inlined Main App Component (from App.tsx) ---
        const getTargetDateForFilename = () => {
            const now = new Date();
            const targetDate = new Date(now);
            const day = now.getDay();
            const hour = now.getHours();
            const minute = now.getMinutes();
            const isWeekday = day >= 1 && day <= 5;
            const isAfternoonOrLater = hour > 12 || (hour === 12 && minute > 0);
            if (isWeekday && isAfternoonOrLater) {
                if (day === 5) {
                    targetDate.setDate(now.getDate() + 3);
                } else {
                    targetDate.setDate(now.getDate() + 1);
                }
            } else if (day === 6) {
                targetDate.setDate(now.getDate() + 2);
            } else if (day === 0) {
                targetDate.setDate(now.getDate() + 1);
            }
            return targetDate;
        };

        const getFileName = () => {
            const targetDate = getTargetDateForFilename();
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const date = String(targetDate.getDate()).padStart(2, '0');
            return `스윗컴퍼니_발송리스트_${year}${month}${date}.xlsx`;
        };

        function App() {
            const [originalFile, setOriginalFile] = useState(null);
            const [processedData, setProcessedData] = useState(null);
            const [processedHeaders, setProcessedHeaders] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [error, setError] = useState(null);

            const resetStateForNewFile = () => {
                setProcessedData(null);
                setError(null);
                setProcessedHeaders([]);
            };

            const handleFileSelect = (file) => {
                setOriginalFile(file);
                resetStateForNewFile();
            };

            const handleProcessFile = useCallback(async () => {
                if (!originalFile) return;
                setIsProcessing(true);
                resetStateForNewFile();
                try {
                    const { processedData: resultData, processedHeaders: resultHeaders } = await readAndProcessFile(originalFile);
                    setProcessedData(resultData);
                    setProcessedHeaders(resultHeaders);
                } catch (err) {
                    setError(String(err));
                } finally {
                    setIsProcessing(false);
                }
            }, [originalFile]);

            const handleDownload = useCallback(() => {
                if (!processedData || processedHeaders.length === 0) return;
                try {
                    const newWorksheet = XLSX.utils.json_to_sheet(processedData, { header: processedHeaders });
                    const newWorkbook = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(newWorkbook, newWorksheet, 'Processed Orders');
                    const excelBuffer = XLSX.write(newWorkbook, { bookType: 'xlsx', type: 'array' });
                    const dataBlob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });
                    saveAs(dataBlob, getFileName());
                } catch (err) {
                    console.error(err);
                    setError('다운로드 파일 생성 중 오류가 발생했습니다.');
                }
            }, [processedData, processedHeaders]);

            const handleSendNaverMail = useCallback(() => {
                if (!processedData || processedHeaders.length === 0) {
                    setError('처리된 데이터가 없습니다.');
                    return;
                }
                const targetDate = getTargetDateForFilename();
                const year = targetDate.getFullYear();
                const month = String(targetDate.getMonth() + 1).padStart(2, '0');
                const date = String(targetDate.getDate()).padStart(2, '0');
                const formattedDate = `${year}-${month}-${date}`;
                const subject = `[스윗컴퍼니 발송리스트] ${formattedDate}`;
                const message = `안녕하세요.\n\n스윗컴퍼니 발송리스트 입니다.\n첨부된 엑셀 파일을 확인해주세요.\n\n잘 부탁드립니다.`;
                const fullContent = `제목: ${subject}\n\n${message}`;

                navigator.clipboard.writeText(fullContent).then(() => {
                    window.open('https://mail.naver.com/write/', '_blank');
                    alert(`📋 메일 내용이 클립보드에 복사되었습니다!\n\n📧 네이버 메일이 새 탭에서 열렸습니다.\n\n🔄 사용법:\n1. 받는 사람 입력\n2. Ctrl+V로 제목과 내용 붙여넣기\n3. 처리된 엑셀 파일 첨부\n4. 발송 완료!`);
                }).catch(() => {
                    window.open('https://mail.naver.com/write/', '_blank');
                    setError('클립보드 복사에 실패했습니다. 네이버 메일에서 수동으로 작성해주세요.');
                    console.log('메일 내용:', fullContent);
                });
            }, [processedData, processedHeaders]);

            return React.createElement("div", { className: "min-h-screen flex flex-col items-center justify-center p-4 sm:p-6 bg-slate-100 dark:bg-slate-800 text-slate-800 dark:text-slate-200" },
                React.createElement("div", { className: "w-full max-w-4xl mx-auto" },
                    React.createElement("header", { className: "text-center mb-8" },
                        React.createElement("h1", { className: "text-3xl sm:text-4xl font-bold text-slate-900 dark:text-white" }, "제임스트렌스 주문서 처리"),
                        React.createElement("p", { className: "mt-2 text-lg text-slate-600 dark:text-slate-400" }, "주문서 파일을 업로드하여 데이터를 자동으로 정리하고 발송하세요.")
                    ),
                    React.createElement("main", { className: "bg-white dark:bg-slate-900/70 rounded-xl shadow-lg p-6 sm:p-8 space-y-6 backdrop-blur-sm" },
                        React.createElement("div", { className: "flex items-start space-x-4" },
                            React.createElement("div", { className: "flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-blue-500 text-white font-bold text-lg" }, "1"),
                            React.createElement("div", null,
                                React.createElement("h2", { className: "text-xl font-semibold text-slate-800 dark:text-white" }, "엑셀 파일 업로드"),
                                React.createElement("p", { className: "text-slate-500 dark:text-slate-400 mt-1" }, "처리할 주문서 엑셀 파일을 선택하거나 끌어다 놓으세요.")
                            )
                        ),
                        React.createElement(FileUpload, { onFileSelect: handleFileSelect, file: originalFile }),
                        React.createElement("div", { className: "flex items-start space-x-4" },
                            React.createElement("div", { className: "flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-blue-500 text-white font-bold text-lg" }, "2"),
                            React.createElement("div", null,
                                React.createElement("h2", { className: "text-xl font-semibold text-slate-800 dark:text-white" }, "데이터 처리 및 미리보기"),
                                React.createElement("p", { className: "text-slate-500 dark:text-slate-400 mt-1" }, "파일 업로드 후, 아래 버튼을 눌러 데이터 정리를 시작하고 결과를 확인합니다.")
                            )
                        ),
                        React.createElement("div", { className: "pl-14" },
                            React.createElement(Button, { onClick: handleProcessFile, disabled: !originalFile || isProcessing, isLoading: isProcessing, className: "w-full sm:w-auto" },
                                React.createElement(ArrowPathIcon, { className: "w-5 h-5 mr-2" }),
                                isProcessing ? '처리 중...' : '파일 처리 및 미리보기'
                            )
                        ),
                        error && React.createElement("div", { className: "pl-14 text-red-500 bg-red-100 dark:bg-red-900/30 p-3 rounded-lg" }, error),
                        processedData && React.createElement(React.Fragment, null,
                            React.createElement(DataTablePreview, { data: processedData, headers: processedHeaders }),
                            React.createElement("div", { className: "flex items-start space-x-4 pt-6" },
                                React.createElement("div", { className: "flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-green-500 text-white" }, 
                                    React.createElement(CheckCircleIcon, { className: "w-6 h-6" })
                                ),
                                React.createElement("div", null,
                                    React.createElement("h2", { className: "text-xl font-semibold text-slate-800 dark:text-white" }, "3. 결과 저장 및 발송"),
                                    React.createElement("p", { className: "text-slate-500 dark:text-slate-400 mt-1" }, "처리된 파일을 다운로드하고, 네이버 메일로 발송합니다.")
                                )
                            ),
                            React.createElement("div", { className: "pl-14 flex flex-wrap gap-4" },
                                React.createElement(Button, { onClick: handleDownload, className: "bg-green-600 hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600 focus:ring-green-500" },
                                    React.createElement(DownloadIcon, { className: "w-5 h-5 mr-2" }),
                                    "엑셀 파일 다운로드"
                                ),
                                React.createElement(Button, { onClick: handleSendNaverMail, className: "bg-sky-600 hover:bg-sky-700 dark:bg-sky-500 dark:hover:bg-sky-600 focus:ring-sky-500" },
                                    React.createElement(PaperAirplaneIcon, { className: "w-5 h-5 mr-2" }),
                                    "메일 발송하기"
                                )
                            ),
                            React.createElement("div", { className: "pl-14 pt-4" },
                                React.createElement("div", { className: "flex items-start p-3 bg-sky-50 dark:bg-sky-900/30 rounded-lg border border-sky-200 dark:border-sky-800" },
                                    React.createElement("div", { className: "flex-shrink-0" },
                                        React.createElement(InformationCircleIcon, { className: "w-5 h-5 text-sky-600 dark:text-sky-400", "aria-hidden": "true" })
                                    ),
                                    React.createElement("div", { className: "ml-3" },
                                        React.createElement("p", { className: "text-sm text-sky-700 dark:text-sky-200" },
                                            React.createElement("strong", null, "사용법 안내:"), " '메일 발송하기' 버튼을 클릭하면 제목과 본문이 클립보드에 복사됩니다. 새로 열린 네이버 메일 창에 붙여넣기(Ctrl+V)하여 사용하세요."
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }

        // --- App Mount ---
        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(React.StrictMode, null, React.createElement(App)));
        } else {
            console.error("Root element not found");
        }
    </script>
</body>
</html>
