<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>제임스트렌스 주문서 처리</title>
    <meta name="description" content="주문 엑셀 파일을 업로드하여 주소, 전화번호, 회사명 데이터를 자동으로 정리하고 다운로드하는 웹 애플리케이션입니다.">
    <meta name="theme-color" content="#f8fafc" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2316a34a'%3E%3Cpath d='M4 2h14a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6l-4-4V4a2 2 0 0 1 2-2zm8 11.5v-3h-3v-2h3v-3h2v3h3v2h-3v3h-2z'/%3E%3C/svg%3E">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- XLSX for Excel processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- FileSaver.js for downloading files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <!-- React via esm.sh -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react/": "https://esm.sh/react@^19.1.1/"
  }
}
</script>
</head>
<body class="bg-slate-50 dark:bg-slate-900">
    <div id="root"></div>

    <script type="module">
        // --- React Imports ---
        import React, { useState, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- Inlined Icon Components ---
        const ArrowPathIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-4.991-2.696h-4.992v.001M21.015 4.356v4.992m0 0h-4.992m4.992 0l-3.181-3.183a8.25 8.25 0 00-11.664 0L2.985 9.348" />
          </svg>
        );

        const CheckCircleIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        );
        
        const DownloadIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
        );

        const ExcelIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}>
            <path d="M4 2h14a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6l-4-4V4a2 2 0 0 1 2-2zm8 11.5v-3h-3v-2h3v-3h2v3h3v2h-3v3h-2zm-3.5-6.5L10 8.5 8.5 7l-1.5 1.5L8.5 10l1.5-1.5L11.5 10l1.5-1.5-1.5-1.5L10 8.5 8.5 7zM6 18h12v2H6v-2z"/>
          </svg>
        );

        const SpinnerIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" {...props}>
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        );

        const TrashIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.067-2.09 1.02-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
          </svg>
        );
        
        const UploadIcon = (props) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
          </svg>
        );

        // --- Inlined UI Components ---
        const Button = ({ isLoading = false, children, className, ...props }) => {
          const baseClasses = "inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-slate-900 transition-all duration-150";
          const colorClasses = "bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600";
          const disabledClasses = "disabled:bg-slate-400 disabled:dark:bg-slate-600 disabled:cursor-not-allowed";

          return (
            <button
              type="button"
              className={`${baseClasses} ${colorClasses} ${disabledClasses} ${className}`}
              disabled={isLoading || props.disabled}
              {...props}
            >
              {isLoading && <SpinnerIcon className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" />}
              {children}
            </button>
          );
        };
        
        const DataTablePreview = ({ data, headers }) => {
          if (!data || data.length === 0) {
            return <p className="pl-14 text-slate-500">표시할 데이터가 없습니다.</p>;
          }

          const displayHeaders = headers && headers.length > 0 ? headers : Object.keys(data[0] || {});
          const previewData = data.slice(0, 10);

          return (
            <div className="pl-14">
                <div className="overflow-x-auto rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50">
                    <table className="min-w-full divide-y divide-slate-200 dark:divide-slate-700">
                        <thead className="bg-slate-100 dark:bg-slate-800">
                        <tr>
                            {displayHeaders.map((header) => (
                            <th
                                key={header}
                                scope="col"
                                className="px-6 py-3 text-left text-sm font-medium text-slate-500 dark:text-slate-300 uppercase tracking-wider whitespace-nowrap"
                            >
                                {header}
                            </th>
                            ))}
                        </tr>
                        </thead>
                        <tbody className="bg-white dark:bg-slate-900 divide-y divide-slate-200 dark:divide-slate-700">
                        {previewData.map((row, rowIndex) => (
                            <tr key={rowIndex} className="hover:bg-slate-50 dark:hover:bg-slate-800/70">
                            {displayHeaders.map((header, colIndex) => (
                                <td key={`${rowIndex}-${colIndex}`} className="px-6 py-4 whitespace-nowrap text-base text-slate-700 dark:text-slate-300">
                                {String(row[header] ?? '')}
                                </td>
                            ))}
                            </tr>
                        ))}
                        </tbody>
                    </table>
                </div>
                {data.length > 10 && (
                    <p className="text-right text-base text-slate-500 mt-2 pr-2">
                        ... and {data.length - 10} more rows.
                    </p>
                )}
            </div>
          );
        };

        const FileUpload = ({ onFileSelect, file }) => {
          const [isDragging, setIsDragging] = useState(false);

          const handleDragEnter = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsDragging(true);
          };

          const handleDragLeave = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsDragging(false);
          };

          const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
          };

          const handleDrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsDragging(false);
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
              onFileSelect(e.dataTransfer.files[0]);
            }
          };

          const handleFileChange = (e) => {
            if (e.target.files && e.target.files.length > 0) {
              onFileSelect(e.target.files[0]);
            }
          };

          const handleRemoveFile = () => {
              onFileSelect(null);
          };

          const baseClasses = "relative block w-full border-2 border-dashed rounded-lg p-8 text-center transition-colors duration-200 ease-in-out cursor-pointer";
          const draggingClasses = "border-blue-500 bg-blue-50 dark:bg-blue-900/30";
          const defaultClasses = "border-slate-300 dark:border-slate-600 hover:border-blue-400 dark:hover:border-blue-500";
          
          if (file) {
            return (
                <div className="pl-14">
                    <div className="flex items-center justify-between p-4 bg-slate-100 dark:bg-slate-800 rounded-lg">
                        <div className="flex items-center space-x-3">
                            <ExcelIcon className="w-8 h-8 text-green-600 dark:text-green-500" />
                            <span className="font-medium text-slate-700 dark:text-slate-300">{file.name}</span>
                        </div>
                        <button onClick={handleRemoveFile} className="p-2 rounded-full text-slate-500 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">
                            <TrashIcon className="w-5 h-5" />
                        </button>
                    </div>
                </div>
            );
          }

          return (
            <div 
                className={`${baseClasses} ${isDragging ? draggingClasses : defaultClasses}`}
                onDragEnter={handleDragEnter}
                onDragLeave={handleDragLeave}
                onDragOver={handleDragOver}
                onDrop={handleDrop}
            >
              <input
                type="file"
                id="file-upload"
                className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                onChange={handleFileChange}
                accept=".xlsx, .xls, .html, .htm"
              />
              <div className="flex flex-col items-center justify-center space-y-3">
                <UploadIcon className="w-12 h-12 text-slate-400 dark:text-slate-500" />
                <p className="text-slate-600 dark:text-slate-400">
                    <span className="font-semibold text-blue-600 dark:text-blue-400">파일 선택</span> 또는 드래그 앤 드롭
                </p>
                <p className="text-xs text-slate-500 dark:text-slate-500">XLSX, XLS, 또는 HTML 파일</p>
              </div>
            </div>
          );
        };
        
        // --- Inlined Data Processing Logic ---
        const findKeyByKeyword = (headers, keyword) => {
            const foundHeader = headers.find(h => 
                h.trim().replace(/\s+/g, '').includes(keyword)
            );
            return foundHeader;
        };
        
        const processOrderData = (data, headers) => {
          const originalAddressKey = findKeyByKeyword(headers, '建物名');
          const prefectureKey = findKeyByKeyword(headers, '都道府県');
          const companyKey = findKeyByKeyword(headers, '会社名');
          const recipientKey = findKeyByKeyword(headers, '届け先名');
          const phoneKey = findKeyByKeyword(headers, '注文者電話番号');
          const recipientPhoneKey = findKeyByKeyword(headers, '수령자휴대폰번호');

          const finalData = data.map(originalRecord => {
            const record = { ...originalRecord };

            if (originalAddressKey && prefectureKey) {
                const fullAddress = record[originalAddressKey];
                if (typeof fullAddress === 'string' && fullAddress.trim() !== '') {
                    const prefectureRegex = /^(東京都|北海道|大阪府|京都府|.{2,3}県)(.*)$/;
                    const match = fullAddress.match(prefectureRegex);
                    
                    if (match && match[1]) {
                        record[prefectureKey] = match[1].trim();
                        record[originalAddressKey] = (match[2] || '').trim();
                    } else {
                        record[prefectureKey] = '';
                    }
                } else {
                    record[prefectureKey] = '';
                }
            }

            if (phoneKey) {
                let finalPhone = record[phoneKey];
                const recipientPhone = recipientPhoneKey ? record[recipientPhoneKey] : undefined;

                const isPhoneEmpty = (phone) => {
                    if (phone === null || phone === undefined || phone === 0) return true;
                    if (typeof phone === 'string') {
                        const trimmed = phone.trim();
                        if (trimmed === '' || trimmed === '-') return true;
                        const cleanedForCheck = trimmed.replace(/^\+81-?/, '').trim();
                        return cleanedForCheck === '' || cleanedForCheck === '-' || cleanedForCheck === '--';
                    }
                    return false;
                };

                if (isPhoneEmpty(finalPhone)) {
                    if (recipientPhone && !isPhoneEmpty(recipientPhone)) {
                        finalPhone = recipientPhone;
                    }
                }
                
                if (finalPhone) {
                    let cleaned = String(finalPhone).replace(/^\+81-?/, '');
                    
                    if (cleaned.trim() === '--' || cleaned.trim() === '-') {
                        record[phoneKey] = '';
                    } else {
                        record[phoneKey] = cleaned.trim();
                    }
                } else {
                    record[phoneKey] = '';
                }
            }

            if (companyKey && recipientKey) {
                const companyName = record[companyKey];
                if (typeof companyName === 'string' && companyName.trim() !== '') {
                    record[recipientKey] = companyName;
                    record[companyKey] = ''; 
                }
            }
            
            if (recipientPhoneKey) {
              delete record[recipientPhoneKey];
            }

            return record;
          });

          const finalHeaders = headers.filter(h => h !== recipientPhoneKey);
          
          return { processedData: finalData, processedHeaders: finalHeaders };
        };
        
        // --- Inlined Main App Component ---
        function App() {
          const [originalFile, setOriginalFile] = useState(null);
          const [processedData, setProcessedData] = useState(null);
          const [processedHeaders, setProcessedHeaders] = useState([]);
          const [isProcessing, setIsProcessing] = useState(false);
          const [error, setError] = useState(null);
          
          const pythonScriptContent = `
import pandas as pd
import re

def find_key_by_keyword(headers, keyword):
    """
    헤더 리스트에서 특정 키워드가 포함된 헤더를 찾습니다.
    공백을 제거하여 정확도를 높입니다.
    """
    for header in headers:
        if keyword in header.strip().replace(" ", ""):
            return header
    return None

def is_phone_empty(phone):
    """
    전화번호 값이 사실상 비어있는지 확인합니다.
    (예: None, 0, '', '-', '+81-')
    """
    if pd.isna(phone) or phone in [0, '0']:
        return True
    if isinstance(phone, str):
        trimmed = phone.strip()
        if trimmed in ['', '-']:
            return True
        # '+81-', '+81--' 와 같은 값도 확인합니다.
        cleaned_for_check = re.sub(r'^\\\\+81-?', '', trimmed).strip()
        if cleaned_for_check in ['', '-', '--']:
            return True
    return False

def process_order_data(df: pd.DataFrame) -> pd.DataFrame:
    """
    주어진 데이터프레임의 주문 데이터를 정리합니다.
    """
    processed_df = df.copy()
    headers = processed_df.columns.tolist()

    original_address_key = find_key_by_keyword(headers, '建物名')
    prefecture_key = find_key_by_keyword(headers, '都道府県')
    company_key = find_key_by_keyword(headers, '会社名')
    recipient_key = find_key_by_keyword(headers, '届け先名')
    phone_key = find_key_by_keyword(headers, '注文者電話番号')
    recipient_phone_key = find_key_by_keyword(headers, '수령자휴대폰번호')

    if original_address_key and prefecture_key:
        processed_df[original_address_key] = processed_df[original_address_key].astype(str).fillna('')
        prefecture_regex = r'^(東京都|北海道|大阪府|京都府|.{2,3}県)(.*)$'
        extracted_parts = processed_df[original_address_key].str.extract(prefecture_regex, expand=True)
        extracted_parts.columns = ['prefecture', 'remaining_address']
        mask = extracted_parts['prefecture'].notna()
        processed_df.loc[mask, prefecture_key] = extracted_parts.loc[mask, 'prefecture'].str.strip()
        processed_df.loc[mask, original_address_key] = extracted_parts.loc[mask, 'remaining_address'].str.strip()
        processed_df.loc[~mask, prefecture_key] = ''

    if phone_key:
        def process_phone(row):
            orderer_phone = row[phone_key]
            recipient_phone = row.get(recipient_phone_key)
            final_phone = orderer_phone
            if is_phone_empty(orderer_phone) and recipient_phone and not is_phone_empty(recipient_phone):
                final_phone = recipient_phone
            if pd.notna(final_phone):
                cleaned = re.sub(r'^\\\\+81-?', '', str(final_phone).strip())
                return '' if cleaned in ['--', '-'] else cleaned.strip()
            return ''
        processed_df[phone_key] = processed_df.apply(process_phone, axis=1)

    if company_key and recipient_key:
        mask = processed_df[company_key].notna() & (processed_df[company_key].astype(str).str.strip() != '')
        processed_df.loc[mask, recipient_key] = processed_df.loc[mask, company_key]
        processed_df.loc[mask, company_key] = ''
    
    if recipient_phone_key and recipient_phone_key in processed_df.columns:
        processed_df = processed_df.drop(columns=[recipient_phone_key])

    return processed_df

def main():
    input_excel_path = './your_input_file.xlsx' 
    output_excel_path = './processed_output.xlsx'
    try:
        df = None
        try:
            df = pd.read_excel(input_excel_path, engine='openpyxl')
        except Exception:
            dfs = pd.read_html(input_excel_path, encoding='utf-8')
            if not dfs: raise ValueError("HTML 파일에서 테이블을 찾을 수 없습니다.")
            df = dfs[0]
        processed_df = process_order_data(df)
        processed_df.to_excel(output_excel_path, index=False, engine='openpyxl')
        print("성공적으로 파일을 저장했습니다!")
    except FileNotFoundError:
        print(f"오류: '{input_excel_path}' 파일을 찾을 수 없습니다.")
    except Exception as e:
        print(f"처리 중 오류가 발생했습니다: {e}")

if __name__ == "__main__":
    main()
`;

          const resetStateForNewFile = () => {
            setProcessedData(null);
            setError(null);
            setProcessedHeaders([]);
          };

          const handleFileSelect = (file) => {
            setOriginalFile(file);
            resetStateForNewFile();
          };

          const handleProcessFile = useCallback(() => {
            if (!originalFile) return;

            setIsProcessing(true);
            resetStateForNewFile();

            const handleFullFileRead = (e, isHtml) => {
                try {
                    const data = e.target?.result;
                    let workbook;

                    if (isHtml) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(data, 'text/html');
                        const table = doc.querySelector('table');
                        if (!table) throw new Error('HTML 파일에서 테이블을 찾을 수 없습니다.');
                        const worksheet = XLSX.utils.table_to_sheet(table, { raw: true });
                        workbook = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
                    } else {
                        workbook = XLSX.read(data, { type: 'array' });
                    }

                    const sheetName = workbook.SheetNames[0];
                    if (!sheetName) throw new Error('파일에 시트가 없습니다.');

                    const worksheet = workbook.Sheets[sheetName];
                    const headers = XLSX.utils.sheet_to_json(worksheet, { header: 1 })[0];
                     if (!headers || headers.length === 0) {
                        throw new Error('파일에서 헤더를 찾을 수 없습니다. 파일이 비어있거나 형식이 잘못되었습니다.');
                    }
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    const { processedData: resultData, processedHeaders: resultHeaders } = processOrderData(jsonData, headers);
                    setProcessedData(resultData);
                    setProcessedHeaders(resultHeaders);

                } catch (err) {
                    console.error(err);
                    setError('파일 처리 중 오류가 발생했습니다. 파일 형식이 올바르지 않거나 손상되었을 수 있습니다.');
                } finally {
                    setIsProcessing(false);
                }
            };
            
            const typeDetectionReader = new FileReader();
            typeDetectionReader.onload = (e) => {
                const arr = new Uint8Array(e.target.result);
                let firstChar = '';
                for (let i = 0; i < arr.length; i++) {
                    const char = String.fromCharCode(arr[i]);
                    if (char.trim() !== '') {
                        firstChar = char;
                        break;
                    }
                }

                const isHtml = firstChar === '<';
                
                const mainReader = new FileReader();
                mainReader.onerror = () => {
                    setError('파일을 읽는 데 실패했습니다.');
                    setIsProcessing(false);
                }
                mainReader.onload = (event) => handleFullFileRead(event, isHtml);

                if (isHtml) {
                    mainReader.readAsText(originalFile, 'UTF-8');
                } else {
                    mainReader.readAsArrayBuffer(originalFile);
                }
            };
            typeDetectionReader.onerror = () => {
                setError('파일 형식을 감지하는 데 실패했습니다.');
                setIsProcessing(false);
            };
            typeDetectionReader.readAsArrayBuffer(originalFile.slice(0, 10));

          }, [originalFile]);
          
          const getTargetDateForFilename = () => {
            const now = new Date();
            const targetDate = new Date(now);
            const day = now.getDay();
            const hour = now.getHours();
            const minute = now.getMinutes();

            const isWeekday = day >= 1 && day <= 5;
            const isAfternoonOrLater = hour > 12 || (hour === 12 && minute > 0);

            if (isWeekday && isAfternoonOrLater) {
              if (day === 5) {
                targetDate.setDate(now.getDate() + 3);
              } else {
                targetDate.setDate(now.getDate() + 1);
              }
            } else if (day === 6) {
              targetDate.setDate(now.getDate() + 2);
            } else if (day === 0) {
              targetDate.setDate(now.getDate() + 1);
            }
            
            return targetDate;
          };
          
          const getFileName = () => {
            const targetDate = getTargetDateForFilename();
            const formattedDate = `${targetDate.getFullYear()}${String(targetDate.getMonth() + 1).padStart(2, '0')}${String(targetDate.getDate()).padStart(2, '0')}`;
            return `스윗컴퍼니_발송리스트_${formattedDate}.xlsx`;
          }

          const handleDownload = useCallback(() => {
            if (!processedData || processedHeaders.length === 0) return;
            try {
                const newWorksheet = XLSX.utils.json_to_sheet(processedData, { header: processedHeaders });
                const newWorkbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(newWorkbook, newWorksheet, 'Processed Orders');
                const excelBuffer = XLSX.write(newWorkbook, { bookType: 'xlsx', type: 'array' });
                const dataBlob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });
                saveAs(dataBlob, getFileName());
            } catch(err) {
                console.error(err);
                setError('다운로드 파일 생성 중 오류가 발생했습니다.');
            }
          }, [processedData, processedHeaders]);

          const handleDownloadPythonScript = useCallback(() => {
            try {
              const blob = new Blob([pythonScriptContent.trim()], { type: 'text/plain;charset=utf-8' });
              saveAs(blob, 'process_orders.py');
            } catch (err) {
              console.error('Failed to download Python script:', err);
              setError('Python 스크립트를 다운로드하는 중 오류가 발생했습니다.');
            }
          }, []);

          return (
            <div className="min-h-screen flex flex-col items-center justify-center p-4 sm:p-6 bg-slate-100 dark:bg-slate-800 text-slate-800 dark:text-slate-200">
              <div className="w-full max-w-4xl mx-auto">
                <header className="text-center mb-8">
                  <h1 className="text-3xl sm:text-4xl font-bold text-slate-900 dark:text-white">제임스트렌스 주문서 처리</h1>
                  <p className="mt-2 text-lg text-slate-600 dark:text-slate-400">주문서 파일을 업로드하여 데이터를 자동으로 정리하세요.</p>
                </header>
                <main className="bg-white dark:bg-slate-900/70 rounded-xl shadow-lg p-6 sm:p-8 space-y-6 backdrop-blur-sm">
                  <div className="flex items-start space-x-4">
                    <div className="flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-blue-500 text-white font-bold text-lg">1</div>
                    <div>
                      <h2 className="text-xl font-semibold text-slate-800 dark:text-white">엑셀 파일 업로드</h2>
                      <p className="text-slate-500 dark:text-slate-400 mt-1">처리할 주문서 엑셀 파일을 선택하거나 끌어다 놓으세요.</p>
                    </div>
                  </div>
                  <FileUpload onFileSelect={handleFileSelect} file={originalFile} />
                  <div className="flex items-start space-x-4">
                    <div className="flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-blue-500 text-white font-bold text-lg">2</div>
                    <div>
                        <h2 className="text-xl font-semibold text-slate-800 dark:text-white">데이터 처리</h2>
                        <p className="text-slate-500 dark:text-slate-400 mt-1">파일 업로드 후, 아래 버튼을 눌러 데이터 정리를 시작합니다.</p>
                    </div>
                  </div>
                  <div className="pl-14">
                    <Button onClick={handleProcessFile} disabled={!originalFile || isProcessing} isLoading={isProcessing} className="w-full sm:w-auto">
                      <ArrowPathIcon className="w-5 h-5 mr-2" />
                      {isProcessing ? '처리 중...' : '파일 처리 시작'}
                    </Button>
                  </div>
                  {error && <div className="pl-14 text-red-500 bg-red-100 dark:bg-red-900/30 p-3 rounded-lg">{error}</div>}
                  {processedData && (
                     <>
                        <div className="flex items-start space-x-4">
                            <div className="flex-shrink-0 flex items-center justify-center h-10 w-10 rounded-full bg-green-500 text-white"><CheckCircleIcon className="w-6 h-6"/></div>
                            <div>
                                <h2 className="text-xl font-semibold text-slate-800 dark:text-white">처리 완료! 결과 확인 및 다운로드</h2>
                                <p className="text-slate-500 dark:text-slate-400 mt-1">데이터 처리가 완료되었습니다. 아래에서 미리보기를 확인하고, 결과를 다운로드하세요.</p>
                            </div>
                        </div>
                        <DataTablePreview data={processedData} headers={processedHeaders} />
                        <div className="pl-14 pt-4">
                            <div className="flex flex-col sm:flex-row sm:items-center sm:space-x-4 space-y-4 sm:space-y-0">
                                <Button onClick={handleDownload} className="w-full sm:w-auto bg-green-600 hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600">
                                    <DownloadIcon className="w-5 h-5 mr-2" />
                                    처리된 파일 다운로드
                                </Button>
                            </div>
                        </div>
                    </>
                  )}
                </main>
                <footer className="text-center mt-8 text-sm text-slate-500 dark:text-slate-400">
                  <div className="flex flex-col sm:flex-row justify-center items-center space-y-2 sm:space-y-0 sm:space-x-4">
                    <p>&copy; {new Date().getFullYear()} Jamestrans. All rights reserved.</p>
                    <button
                      onClick={handleDownloadPythonScript}
                      className="text-blue-600 dark:text-blue-400 hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded"
                    >
                      Python 스크립트 다운로드
                    </button>
                  </div>
                </footer>
              </div>
            </div>
          );
        }

        // --- Application Mount ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("Could not find root element to mount to");
        }
        const root = ReactDOM.createRoot(rootElement);
        root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
    <script>
        // --- Inlined Service Worker ---
        if ('serviceWorker' in navigator) {
            const swContent = `
                const CACHE_NAME = 'jamestrans-order-processor-v2';
                self.addEventListener('install', event => {
                  self.skipWaiting();
                  event.waitUntil(
                    caches.open(CACHE_NAME).then(cache => {
                      // Cache the main HTML file on install
                      return cache.add(new Request(self.location.href));
                    })
                  );
                });
                self.addEventListener('fetch', event => {
                  // For navigation requests, try the cache first.
                  if (event.request.mode === 'navigate') {
                    event.respondWith(
                      caches.match(event.request).then(response => {
                        return response || fetch(event.request);
                      })
                    );
                  }
                  // For other requests, just fetch from network as they are CDNs.
                  return;
                });
                self.addEventListener('activate', event => {
                  const cacheWhitelist = [CACHE_NAME];
                  event.waitUntil(
                    caches.keys().then(cacheNames => {
                      return Promise.all(
                        cacheNames.map(cacheName => {
                          if (cacheWhitelist.indexOf(cacheName) === -1) {
                            return caches.delete(cacheName);
                          }
                        })
                      );
                    })
                  );
                });
            `;
            // Create a blob from the SW content to register it from a data URL.
            const blob = new Blob([swContent], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);

            window.addEventListener('load', () => {
              navigator.serviceWorker.register(swUrl).then(registration => {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
              }, err => {
                console.log('ServiceWorker registration failed: ', err);
              });
            });
        }
    </script>
</body>
</html>
